<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="前言在上文介绍过控制反转之后，本来打算写篇文章介绍下控制反转的常见模式-依赖注入。在翻看资料的时候，发现了一篇好文Dependency injection in JavaScript，就不自己折腾了，结合自己理解翻译一下，好文共赏。">
<meta property="og:type" content="article">
<meta property="og:title" content="译-javascript中的依赖注入">
<meta property="og:url" content="http://xxdy.tech/2018/10/25/Di/index.html">
<meta property="og:site_name" content="雨打梨梦三村边">
<meta property="og:description" content="前言在上文介绍过控制反转之后，本来打算写篇文章介绍下控制反转的常见模式-依赖注入。在翻看资料的时候，发现了一篇好文Dependency injection in JavaScript，就不自己折腾了，结合自己理解翻译一下，好文共赏。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-10-25T08:22:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="译-javascript中的依赖注入">
<meta name="twitter:description" content="前言在上文介绍过控制反转之后，本来打算写篇文章介绍下控制反转的常见模式-依赖注入。在翻看资料的时候，发现了一篇好文Dependency injection in JavaScript，就不自己折腾了，结合自己理解翻译一下，好文共赏。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://xxdy.tech/2018/10/25/Di/"/>





  <title>译-javascript中的依赖注入 | 雨打梨梦三村边</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雨打梨梦三村边</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">潇湘待雨</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xxdy.tech/2018/10/25/Di/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="felix.pan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雨打梨梦三村边">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">译-javascript中的依赖注入</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-25T00:00:00+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://juejin.im/post/5bd07377e51d457a58075974" target="_blank" rel="noopener">上文</a>介绍过控制反转之后，本来打算写篇文章介绍下控制反转的常见模式-依赖注入。在翻看资料的时候，发现了一篇好文<a href="http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript" target="_blank" rel="noopener">Dependency injection in JavaScript</a>，就不自己折腾了，结合自己理解翻译一下，好文共赏。<br><a id="more"></a><br>我喜欢引用这样一句话‘编程是对复杂性的管理’。可能你也听过计算机世界是一个巨大的抽象结构。我们简单的包装东西并重复的生产新的工具。思考那么一下下，我们使用的编程语言都包括内置的功能，这些功能可能是基于其他低级操作的抽象方法，包括我们是用的javascript。<br>迟早，我们都会需要使用别的开发者开发的抽象功能，也就是我们要依赖其他人的代码。我希望使用没有依赖的模块，显然这是很难实现的。即使你创建了很好的像黑盒一样的组件，但总有个将所有部分合并起来的地方。这就是依赖注入起作用的地方，当前来看，高效管理依赖的能力是迫切需要的，本文总结了原作者对这个问题的看法。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>假设我们有两个模块，一个是发出ajax请求的服务，一个是路由：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> service = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">'Service'</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> router = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">'Router'</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是另一个依赖了上述模块的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = service();</span><br><span class="line">    <span class="keyword">var</span> r = router();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了更有趣一点，该函数需要接受一个参数。当然我们可以使用上面的代码，但是这不太灵活。<br>如果我们想使用ServiceXML、ServiceJSON，或者我们想要mock一些测试模块，这样我们不能每次都是编辑函数体。为了解决这个现状，首先我们提出将依赖当做参数传给函数，如下：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">service, router, other</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = service();</span><br><span class="line">    <span class="keyword">var</span> r = router();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，我们把需要的模块的具体实例传递过来。然而这样有个新的问题：想一下如果dosomething函数在很多地方被调用，如果有第三个依赖条件，我们不能改变所有的调用doSomething的地方。<br>举个小栗子：<br>假如我们有很多地方用到了doSomething：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">var</span> a = doSomething(service,router,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//b.js </span></span><br><span class="line"><span class="keyword">var</span> b = doSomething(service,router,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 假如依赖条件更改了，即doSomething需要第三个依赖，才能正常工作</span></span><br><span class="line"><span class="comment">// 这时候就需要在上面不同文件中修改了，如果文件数量够多，就不合适了。</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params">service, router, third,thother</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = service();</span><br><span class="line">    <span class="keyword">var</span> r = router();</span><br><span class="line">    <span class="comment">//***</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因此，我们需要一个帮助我们来管理依赖的工具。这就是依赖注入器想要解决的问题，先看一下我们想要达到的目标：</p>
<ul>
<li>可以注册依赖 </li>
<li>注入器应该接受一个函数并且返回一个已经获得需要资源的函数</li>
<li>我们不应该写复杂的代码，需要简短优雅的语法</li>
<li>注入器应该保持传入函数的作用域</li>
<li>被传入的函数应该可以接受自定义参数，不仅仅是被描述的依赖。</li>
</ul>
<p>看起来比较完美的列表就如上了，让我们来尝试实现它。</p>
<h3 id="requirejs-AMD的方式"><a href="#requirejs-AMD的方式" class="headerlink" title="requirejs/AMD的方式"></a>requirejs/AMD的方式</h3><p>大家都可能听说过requirejs，它是很不错的依赖管理方案。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'service'</span>, <span class="string">'router'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">service, router</span>) </span>&#123;       </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种思路是首先声明需要的依赖，然后开始编写函数。这里参数的顺序是很重要的。我们来试试写一个名为injector的模块，可以接受相同语法。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = injector.resolve([<span class="string">'service'</span>, <span class="string">'router'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">service, router, other</span>) </span>&#123;</span><br><span class="line">    expect(service().name).to.be(<span class="string">'Service'</span>);</span><br><span class="line">    expect(router().name).to.be(<span class="string">'Router'</span>);</span><br><span class="line">    expect(other).to.be(<span class="string">'Other'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">doSomething(<span class="string">"Other"</span>);</span><br></pre></td></tr></table></figure>
<p>这里稍微停顿一下，解释一下doSomething的函数体，使用expect.js来作为断言库来确保我的代码能像期望那样正常工作。体现了一点点<a href="https://zh.wikipedia.org/wiki/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">TDD（测试驱动开发）</a>的开发模式。</p>
<p>下面是我们injector模块的开始，一个单例模式是很好的选择，因此可以在我们应用的不同部分运行的很不错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> injector = &#123;</span><br><span class="line">    dependencies: &#123;&#125;,</span><br><span class="line">    register: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependencies[key] = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: <span class="function"><span class="keyword">function</span>(<span class="params">deps, func, scope</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码来看，确实是一个很简单的对象。有两个函数和一个作为存储队列的变量。我们需要做的是检查deps依赖数组，并且从dependencies队列中查找答案。剩下的就是调用.apply方法来拼接被传递过来函数的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//处理之后将依赖项当做参数传入给func</span></span><br><span class="line">resolve: <span class="function"><span class="keyword">function</span>(<span class="params">deps, func, scope</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">//处理依赖，如果依赖队列中不存在对应的依赖模块，显然该依赖不能被调用那么报错，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length, d=deps[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.dependencies[d]) &#123;</span><br><span class="line">            args.push(<span class="keyword">this</span>.dependencies[d]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Can\'t resolve '</span> + d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理参数，将参数拼接在依赖后面，以便和函数中参数位置对应</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        func.apply(scope || &#123;&#125;, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>)));</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果scope存在，是可以被有效传递的。Array.prototype.slice.call(arguments, 0)将arguments(类数组)转换成真正的数组。<br>目前来看很不错的，可以通过测试。当前的问题时，我们必须写两次需要的依赖，并且顺序不可变动，额外的参数只能在最后面。   </p>
<h3 id="反射实现"><a href="#反射实现" class="headerlink" title="反射实现"></a>反射实现</h3><p>从维基百科来说，反射是程序在运行时可以检查和修改对象结构和行为的一种能力。简而言之，在js的上下文中，是指读取并且分析对象或者函数的源码。看下开头的doSomething，如果使用doSomething.toString() 可以得到下面的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"function (service, router, other) &#123;</span></span><br><span class="line"><span class="string">    var s = service();</span></span><br><span class="line"><span class="string">    var r = router();</span></span><br><span class="line"><span class="string">&#125;"</span></span><br></pre></td></tr></table></figure>
<p>这种将函数转成字符串的方式赋予我们获取预期参数的能力。并且更重要的是，他们的name。下面是Angular依赖注入的实现方式，我从Angular那拿了点可以获取arguments的正则表达式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span><br></pre></td></tr></table></figure>
<p>这样我们可以修改resolve方法了：</p>
<h4 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h4><p>这里，我将测试例子拿上来应该更好理解一点。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = injector.resolve(<span class="function"><span class="keyword">function</span>(<span class="params">service, other, router</span>) </span>&#123;</span><br><span class="line">    expect(service().name).to.be(<span class="string">'Service'</span>);</span><br><span class="line">    expect(router().name).to.be(<span class="string">'Router'</span>);</span><br><span class="line">    expect(other).to.be(<span class="string">'Other'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">doSomething(<span class="string">"Other"</span>);</span><br></pre></td></tr></table></figure>
<p>继续来看我们的实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// agrs 传给func的参数数组，包括依赖模块及自定义参数</span></span><br><span class="line">    <span class="keyword">var</span> func, deps, scope, args = [], self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 获取传入的func，主要是为了下面来拆分字符串</span></span><br><span class="line">    func = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 正则拆分，获取依赖模块的数组</span></span><br><span class="line">    deps = func.toString().match(<span class="regexp">/^functions*[^(]*(s*([^)]*))/m</span>)[<span class="number">1</span>].replace(<span class="regexp">/ /g</span>, <span class="string">''</span>).split(<span class="string">','</span>);</span><br><span class="line">    <span class="comment">//待绑定作用域，不存在则不指定</span></span><br><span class="line">    scope = <span class="built_in">arguments</span>[<span class="number">1</span>] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将arguments转为数组</span></span><br><span class="line">        <span class="comment">// 即后面再次调用的时候，doSomething("Other");   </span></span><br><span class="line">        <span class="comment">// 这里的Other就是a，用来补充缺失的模块。</span></span><br><span class="line">        <span class="keyword">var</span> a = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//循环依赖模块数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> d = deps[i];</span><br><span class="line">            <span class="comment">// 依赖队列中模块存在且不为空的话，push进参数数组中。</span></span><br><span class="line">            <span class="comment">// 依赖队列中不存在对应模块的话从a中取第一个元素push进去(shift之后，数组在改变)</span></span><br><span class="line">            args.push(self.dependencies[d] &amp;&amp; d != <span class="string">''</span> ? self.dependencies[d] : a.shift());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依赖当做参数传入</span></span><br><span class="line">        func.apply(scope || &#123;&#125;, args);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个正则来处理函数时，可以得到下面结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"function (service, router, other)"</span>, <span class="string">"service, router, other"</span>]</span><br></pre></td></tr></table></figure>
<p>我们需要的只是第二项，一旦我们清除数组并拆分字符串，我们将会得到依赖数组。主要变化在下面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">args.push(self.dependencies[d] &amp;&amp; d != <span class="string">''</span> ? self.dependencies[d] : a.shift());</span><br></pre></td></tr></table></figure>
<p>这样我们就循环遍历依赖项，如果缺少某些东西，我们可以尝试从arguments对象中获取。幸好，当数组为空的时候shift方法也只是返回undefined而非抛错。所以新版的用法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不用在前面声明依赖模块了</span></span><br><span class="line"><span class="keyword">var</span> doSomething = injector.resolve(<span class="function"><span class="keyword">function</span>(<span class="params">service, other, router</span>) </span>&#123;</span><br><span class="line">    expect(service().name).to.be(<span class="string">'Service'</span>);</span><br><span class="line">    expect(router().name).to.be(<span class="string">'Router'</span>);</span><br><span class="line">    expect(other).to.be(<span class="string">'Other'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">doSomething(<span class="string">"Other"</span>);</span><br></pre></td></tr></table></figure>
<p>这样就不用重复声明了，顺序也可变。我们复制了Angular的魔力。<br>然而，这并不完美，压缩会破坏我们的逻辑，这是反射注入的一大问题。因为压缩改变了参数的名称所以我们没有能力去解决这些依赖。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显然根据key来匹配就是有问题的了</span></span><br><span class="line"><span class="keyword">var</span> doSomething=<span class="function"><span class="keyword">function</span>(<span class="params">e,t,n</span>)</span>&#123;<span class="keyword">var</span> r=e();<span class="keyword">var</span> i=t()&#125;</span><br></pre></td></tr></table></figure>
<p>Angular团队的解决方案如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = injector.resolve([<span class="string">'service'</span>, <span class="string">'router'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">service, router</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>看起来就和开始的require.js的方式一样了。作者个人不能找到更优的解决方案，为了适应这两种方式。最终方案看起来如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> injector = &#123;</span><br><span class="line">    dependencies: &#123;&#125;,</span><br><span class="line">    register: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependencies[key] = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> func, deps, scope, args = [], self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 该种情况是兼容形式，先声明</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">0</span>] === <span class="string">'string'</span>) &#123;</span><br><span class="line">            func = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">            deps = <span class="built_in">arguments</span>[<span class="number">0</span>].replace(<span class="regexp">/ /g</span>, <span class="string">''</span>).split(<span class="string">','</span>);</span><br><span class="line">            scope = <span class="built_in">arguments</span>[<span class="number">2</span>] || &#123;&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 反射的第一种方式</span></span><br><span class="line">            func = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">            deps = func.toString().match(<span class="regexp">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span>)[<span class="number">1</span>].replace(<span class="regexp">/ /g</span>, <span class="string">''</span>).split(<span class="string">','</span>);</span><br><span class="line">            scope = <span class="built_in">arguments</span>[<span class="number">1</span>] || &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> d = deps[i];</span><br><span class="line">                args.push(self.dependencies[d] &amp;&amp; d != <span class="string">''</span> ? self.dependencies[d] : a.shift());</span><br><span class="line">            &#125;</span><br><span class="line">            func.apply(scope || &#123;&#125;, args);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在resolve接受两或者三个参数，如果是两个就是我们写的第一种了，如果是三个，会将第一个参数解析并填充到deps。下面就是测试例子(我一直认为将这段例子放在前面可能大家更好阅读一些。)：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缺失了一项模块other</span></span><br><span class="line"><span class="keyword">var</span> doSomething = injector.resolve(<span class="string">'router,,service'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    expect(a().name).to.be(<span class="string">'Router'</span>);</span><br><span class="line">    expect(b).to.be(<span class="string">'Other'</span>);</span><br><span class="line">    expect(c().name).to.be(<span class="string">'Service'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这里传的Other将会用来拼凑</span></span><br><span class="line">doSomething(<span class="string">"Other"</span>);</span><br></pre></td></tr></table></figure>
<p>可能会注意到argumets[0]中确实了一项，就是为了测试填充功能的。</p>
<h3 id="直接注入作用域"><a href="#直接注入作用域" class="headerlink" title="直接注入作用域"></a>直接注入作用域</h3><p>有时候，我们使用第三种的注入方式，它涉及到函数作用域的操作(或者其他名字，this对象)，并不经常使用  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> injector = &#123;</span><br><span class="line">    dependencies: &#123;&#125;,</span><br><span class="line">    register: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependencies[key] = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: <span class="function"><span class="keyword">function</span>(<span class="params">deps, func, scope</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        scope = scope || &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;deps.length, d=deps[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.dependencies[d]) &#123;</span><br><span class="line">                <span class="comment">//区别就在这里了，直接将依赖加到scope上</span></span><br><span class="line">                <span class="comment">//这样就可以直接在函数作用域中调用了</span></span><br><span class="line">                scope[d] = <span class="keyword">this</span>.dependencies[d];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Can\'t resolve '</span> + d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            func.apply(scope || &#123;&#125;, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们做的就是将依赖加到作用域上，这样的好处是不用再参数里加依赖了，已经是函数作用域的一部分了。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = injector.resolve([<span class="string">'service'</span>, <span class="string">'router'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">other</span>) </span>&#123;</span><br><span class="line">    expect(<span class="keyword">this</span>.service().name).to.be(<span class="string">'Service'</span>);</span><br><span class="line">    expect(<span class="keyword">this</span>.router().name).to.be(<span class="string">'Router'</span>);</span><br><span class="line">    expect(other).to.be(<span class="string">'Other'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">doSomething(<span class="string">"Other"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>依赖注入是我们所有人都做过的事情中的一种，可能没有意识到罢了。即使没有听过，你也可能用过很多次了。<br>通过这篇文章对于这个熟悉而又陌生的概念的了解加深了不少，希望能帮助到有需要的同学。最后个人能力有限，翻译有误的地方欢迎大家指出，共同进步。<br>再次感谢原文作者<a href="http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript" target="_blank" rel="noopener">原文地址</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/19/ioc/" rel="next" title="前端解读控制反转(IOC)">
                <i class="fa fa-chevron-left"></i> 前端解读控制反转(IOC)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/26/AOP/" rel="prev" title="前端解读面向切面编程(AOP)">
                前端解读面向切面编程(AOP) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">felix.pan</p>
              <p class="site-description motion-element" itemprop="description">潇湘待雨个人博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text"><a href="#&#x524D;&#x8A00;" class="headerlink" title="&#x524D;&#x8A00;"></a>&#x524D;&#x8A00;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目标"><span class="nav-number">2.</span> <span class="nav-text"><a href="#&#x76EE;&#x6807;" class="headerlink" title="&#x76EE;&#x6807;"></a>&#x76EE;&#x6807;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#requirejs-AMD的方式"><span class="nav-number">2.1.</span> <span class="nav-text"><a href="#requirejs-AMD&#x7684;&#x65B9;&#x5F0F;" class="headerlink" title="requirejs/AMD&#x7684;&#x65B9;&#x5F0F;"></a>requirejs/AMD&#x7684;&#x65B9;&#x5F0F;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射实现"><span class="nav-number">2.2.</span> <span class="nav-text"><a href="#&#x53CD;&#x5C04;&#x5B9E;&#x73B0;" class="headerlink" title="&#x53CD;&#x5C04;&#x5B9E;&#x73B0;"></a>&#x53CD;&#x5C04;&#x5B9E;&#x73B0;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tip"><span class="nav-number">2.2.1.</span> <span class="nav-text"><a href="#tip" class="headerlink" title="tip"></a>tip</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接注入作用域"><span class="nav-number">2.3.</span> <span class="nav-text"><a href="#&#x76F4;&#x63A5;&#x6CE8;&#x5165;&#x4F5C;&#x7528;&#x57DF;" class="headerlink" title="&#x76F4;&#x63A5;&#x6CE8;&#x5165;&#x4F5C;&#x7528;&#x57DF;"></a>&#x76F4;&#x63A5;&#x6CE8;&#x5165;&#x4F5C;&#x7528;&#x57DF;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结束语"><span class="nav-number">2.4.</span> <span class="nav-text"><a href="#&#x7ED3;&#x675F;&#x8BED;" class="headerlink" title="&#x7ED3;&#x675F;&#x8BED;"></a>&#x7ED3;&#x675F;&#x8BED;</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">felix.pan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
